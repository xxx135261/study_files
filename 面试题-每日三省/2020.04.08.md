##### 1、Object.defineProperty
- Object.defineProperty(obj,prop,descriptior)
1、obj:需要定义的属性对象
2、prop:需要定义（创建）或修改的属性的名字
3、descriptor:需要定义或修改的属性的描述符，可以是一个对象
```
var person = {

}
Object.defineProperty(persion,"age",{
	configurable:true,//可以修改默认属性
	enumerable:true,//可以被枚举
	writable:true,//可以修改这个属性的值
	value:1//定义一个初始值为1
})
```
现在我们来修改一下默认的值
```
Object.defineProperty(person,'age',{
	configurable:true,   //	configurable:false, 不允许修改默认属性了,就算再回改回来也报错。
	enumerable:false,
	writable:false,
	value:1
})
console.log(person)  //Object {age:1}
person.age = 2;
console.log(person)  //Object {age:1},因为writable设为了false,所以不可以写，严格模式下会报错
for(var k in person){
	console.log(k)  //不起作用,因为enumerable的值被设置为false了
}
```
- 访问器属性
1、get在读取属性时调用的函数，默认值为undefined
2、set在设置属性时调用的函数，默认值为undefined
3、访问器属性不能直接定义，只能通过`Object.defineProperty`来定义
```
var person = {
	age:1
}
Object.defineProperty(person,'age',{
	get(){
		return 3
	},
	set(val){
		console.log(val)
	}
})
person.age// 3,我们明明写的是a:1,怎么返回的3呢?这就是get()的威力了
person.a = 5// 5,相应的设置的时候执行了set()函数
```
模拟一个访问和设置的默认行为
**举例说明Object.defineProperty什么情况下会造成循环引用导致栈溢出**
```
var person = {
	age:1
}
Object.defineProperty(person,'age',{
	get(){
		return this.age
	},
	set(val){
		this.age = val
	}
})

person.age   报错：Maximum call stack size exceeded，循环引用导致栈溢出

person.age --> get.call(person) -->this.age --> person.age --> get.call(person) --> this.age --> .......
```
